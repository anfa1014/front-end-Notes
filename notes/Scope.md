### 作用域
需要一套良好的设计规则来存储变量，并且之后可以方便的找到这些变量，这套规则称之为作用域。

负责收集并维护由所有声明的标志符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标志符的访问权限。

两种类型：词法作用域和动态作用域

### 传统编译过程
1. 词法分析
2. 语法分析（构建语法树）
3. 代码生成

js的编译过程不是发生在构建之前的，大部分情况下发生在代码执行前的几微秒

### 变量查询
* LHS 找到变量容器本身 ，如果找不到 会创建新变量
* RHS 找到变量的具体值 ，如果找不到，会抛出异常，ReferenceError

### 词法作用域
词法作用域是定义在词法阶段的作用域，是由你在写代码时将变量和块作用域写在哪里决定的。

修改作用域：eval和with 

* eval 修改已存在的作用域，setTimeout和setInterval类似
* with 以对象作为新的作用域，属性为标识符

### 函数作用域
函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

### 立即执行函数表达式两种写法
* (function(){...})()
* (function(){...}())

### 块作用域
* with
* try/catch
* let ①为其声明的变量隐式劫持所在的块作用域 ②不会变量提升
* const

### var a = 2
1. var a  在编译阶段
2. a=2 在执行阶段
3. 只有声明会 提前， 赋值不会提前
4. 函数提升 优先于 变量提升

### 闭包
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

无论通过何种手段内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

在定时器，事件监听器，ajax请求，跨窗口通信或者任何其他的异步任务中，只要使用了回调函数，实际上就是在使用闭包

#### 延迟函数的回调会在循环结束时才执行
